const DATA_TYPE_KEY="@DT";const DATA_VALUE_KEY="@v";const _dtv=(k,v)=>({[DATA_TYPE_KEY]:k,[DATA_VALUE_KEY]:v});function _json_replacer(key,value){if(value instanceof Map){return _dtv("map",Array.from(value.entries()))}else if(value instanceof Set){return _dtv("set",Array.from(value.values()))}return value}function _json_reviver(key,value){if(typeof value==="object"&&value!==null&&Object.hasOwn(value,DATA_TYPE_KEY)){if(value[DATA_TYPE_KEY]==="map"){return new Map(value[DATA_VALUE_KEY])}else if(value[DATA_TYPE_KEY]==="set"){return new Set(value[DATA_VALUE_KEY])}}return value}export function toJSON(value,space){return JSON.stringify(value,_json_replacer,space)}export function fromJSON(text){return JSON.parse(text,_json_reviver)}export function toNative(value){const plain=toJSON(value);return JSON.parse(plain)}export function fromNative(native){const text=JSON.stringify(native);return fromJSON(text)}export class InvalidJSONError extends Error{constructor(message){super(message);this.name="InvalidJSONError"}}export function extractJSON(text){let firstOpen=-1,firstClose,candidate;firstOpen=text.indexOf("{",firstOpen+1);if(firstOpen===-1){throw new InvalidJSONError}do{firstClose=text.lastIndexOf("}");if(firstClose<=firstOpen){throw new InvalidJSONError}do{candidate=text.substring(firstOpen,firstClose+1);try{let res=fromJSON(candidate);return[res,firstOpen,firstClose+1]}catch(e){}firstClose=text.substring(0,firstClose).lastIndexOf("}")}while(firstClose>firstOpen);firstOpen=text.indexOf("{",firstOpen+1)}while(firstOpen!==-1);throw new InvalidJSONError}